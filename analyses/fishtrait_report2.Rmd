---
title: "Fish trait analyses"
author: "Jehaaaaaanne, Thibaaaaaault, Laureeeeeeent"
date: "`r date()`"
output: 
  pdf_document

bibliography: '/home/moi/datahome/work/biblio/enfin/biblioloran.bib'
---

```{r packageandoptions, include=T,cache=F,echo=F,warning=F,message=F,progress=F,verbose=F,results="hide"}
#knitr option
operationnel<-TRUE
knitr::opts_chunk$set(echo=FALSE, 
		      warning=!operationnel, 
		      message=!operationnel,
		      fig.height=8,
		      progress=!operationnel,
		      verbose=!operationnel,
		      include=TRUE,
		      dev='png',autodep=FALSE)
#package
library(dplyr)
library(ggplot2)
library(cluster)
library(FactoMineR)
library(factoextra)
library(fpc)
library(openxlsx)
library(googlesheets4)
library(fpc)
#stuff for table and fig
options(kableExtra.latex.load_packages = FALSE)
library(kableExtra)
library(captioner)
#initialize functions for tables and fig legends
tabcap <- captioner(prefix = "Table")
figcap <- captioner(prefix = "Figure")
#setting the working directory
#if needed do it here
#setwd....

```

# Framework

This document presents the analyses done on the fish trait matrix.

# Data

## Abundances

DATRAS CGFS

## Fish "traits"

### Sources

Sources: 
 - our own work on fishbase and IUCN
 - Beuhkof et al Pangea database and
 - benthos : xxx

### Raw data 

Based on the jointure scripts

```{r datafish0, include=T,cache=T,echo=F}
load("../data/Traitfish.Rdata") #traitfish
load("../data/Traitbenthos.Rdata") #traitbenthos
load("../data/Traitceph.Rdata") #traitceph
```

### Missing values imputation

```{r missingvalfishtrait,cache=TRUE}
#explo data
diagmiss<-function(fishtrait){
		nbid<-fishtrait%>%summarise_all(n_distinct)%>%t()
	nbNA<-function(a){a[a==""]<-NA;sum(is.na(a))}
		nbNA<-fishtrait%>%summarise_all(nbNA)%>%t()
		return(data.frame(nbid=nbid,nbNA=nbNA))
}
diagmiss(traitfish)

#imputation
diagmiss(traitfish)
traitfish0<-mice::mice(traitfish,m=1)#,defaultMethod=c("pmm","rf","rf","rf"))
traitfish0<-mice::complete(traitfish0)
diagmiss(traitfish0)

diagmiss(traitbenthos)
traitben0<-mice::mice(traitbenthos,m=1)#,defaultMethod=c("pmm","rf","rf","rf"))
traitben0<-mice::complete(traitben0)
diagmiss(traitben0)

#benthos


```

### Quantitative to qualitative data

```{r quant2catfishtrait,cache=TRUE}
fishtraitnew<-traitfish0
#now categorize stuff
#categorize numerical values 
catvar<-function(a,value){
	  	value<-c(0,as.vector(value))
	print(value)
		lval<-length(value)
		interval<-paste0("[",round(value[-lval],3),",",round(value[-1],3),"[")
			a1<-interval[findInterval(a,value,all.inside=T)]
				return(a1)
}

#a quick check for the function
table(fishtraitnew$tl,catvar(fishtraitnew$tl,c(1:5)))
fishtraitnew$tl<-catvar(fishtraitnew$tl,c(1:5))
#table(fishtraitnew$offspring.size,catvar(fishtraitnew$offspring.size,c(4,400)))
#fishtraitnew$offspring.size<-catvar(fishtraitnew$offspring.size,c(4,400))
table(fishtraitnew$MaturityAge,catvar(fishtraitnew$MaturityAge,c(2,3,4,5,14)))
fishtraitnew$MaturityAge<-catvar(fishtraitnew$MaturityAge,c(2,3,4,5,14))
#table(fishtraitnew$fecundity,catvar(fishtraitnew$fecundity,c(1000,10000,100000,1000000)))
#fishtraitnew$fecundity<-catvar(fishtraitnew$fecundity,c(1000,10000,100000,1000000))
table(fishtraitnew$growth.coefficient,catvar(fishtraitnew$growth.coefficient,c(.1,.2,.3,.4,.5,2)))
fishtraitnew$growth.coefficient<-catvar(fishtraitnew$growth.coefficient,c(.1,.2,.3,.4,.5,2))
table(fishtraitnew$length.max,catvar(fishtraitnew$length.max,c(50,100,200)))
fishtraitnew$length.max<-catvar(fishtraitnew$length.max,c(50,100,200))
table(fishtraitnew$age.max,catvar(fishtraitnew$age.max,c(5,10,20,60)))
fishtraitnew$age.max<-catvar(fishtraitnew$age.max,c(5,10,20,60))

#to get an idea of categories
diagmiss(fishtraitnew)

#benthos
bentraitnew<-traitben0
#all categories !!!
diagmiss(bentraitnew)



```


### Multiple correspondance analysis

Multiplle correspondance analyses on the trait matrix using Burt tables.

### Fish

```{r MCAfishtrait,cache=TRUE}
#MCA + classif
pipo<-data.frame(fishtraitnew[,-1])
#pipo<-data.frame(fishtraitnew[,c(1,2,3,4,5,7,8)])
row.names(pipo) <- fishtraitnew$Taxons
#correspodance anlysis on Burt table
rez<-MCA(pipo,ncp=999,method="Burt",graph=F)
plt1<-plotellipses(rez,axes=c(1,2))
plt2<-plotellipses(rez,axes=c(1,3))
```
```{r MCAfishtrait1,cache=TRUE}
print(plt1)
```

```{r MCAfishtrait2,cache=TRUE}
print(plt2)
```

With three axes 48.55% of total variance mapped.
Quick analyses: axe one for big fishes with intermediate growth parameters (size, trophic level, age, age maturity) versus small one with low life expectancy, low trophic level and co. Axe two and three not so clear, but help to distinguish the axe one properties. 

### Benthos 

```{r MCAbentrait,cache=TRUE}
#MCA + classif
pipoben<-data.frame(bentraitnew[,-1])
#pipo<-data.frame(fishtraitnew[,c(1,2,3,4,5,7,8)])
row.names(pipoben) <- bentraitnew$Taxons
#correspodance anlysis on Burt table
rezben<-MCA(pipoben,ncp=999,method="Burt",graph=F)
plt1<-plotellipses(rezben,axes=c(1,2))
plt2<-plotellipses(rezben,axes=c(1,3))
```
```{r MCAbentrait1,cache=TRUE}
print(plt1)
```

```{r MCAbentrait2,cache=TRUE}
print(plt2)



### Groups identification in the multiple correspondance analysis spaces

The MCA results are used to identify group of similar traits caracteristics in
the MCA space. First methods test using Hennig approach and the fpc packages, 
then group with the best method.
Methods tested with 2 to 20 groups:

- 4 random classification (cf "stupid" classifiers in Hennig),
- hierarchical clustering  with ward, single, complete, average, mcquitty criterions,
- kmeans,
- clara methods (large dataset computation methods).


```{r classiftestmethod,cache=TRUE}
#then Hennig, C. (2017) Cluster validation by measurement of clustering
#characteristics relevant to the user. In C. H. Skiadas (ed.) Proceedings of
#ASMDA 2017, 501-520, https://arxiv.org/abs/1703.09282
# using clusterbenchmark from fpc
if(!file.exists("cbs.rds")){
set.seed(666) #the number of the beaaasttt
  options(digits=3)
clustermethod=c("kmeansCBI","hclustCBI","hclustCBI","hclustCBI","hclustCBI","hclustCBI","claraCBI")
clustermethodpars <- list()
clustermethodpars[[2]] <- clustermethodpars[[3]] <- list()
clustermethodpars[[4]] <-  clustermethodpars[[5]] <-list()
clustermethodpars[[6]]<-   clustermethodpars[[7]] <-list()
clustermethodpars[[2]]$method <- "ward.D2"
clustermethodpars[[3]]$method <- "single"
clustermethodpars[[4]]$method <- "complete"
clustermethodpars[[5]]$method <- "average"
clustermethodpars[[6]]$method <- "mcquitty"
#clustermethodpars[[7]]$method <- ""
methodname <- c("kmeans","ward","single","complete","average","mcquitty","clara")
cbs <-  clusterbenchstats(rez$ind$coord,G=2:20,
			  clustermethod=clustermethod,scaling=FALSE,
			  methodname=methodname,
			  distmethod=rep(FALSE,length(clustermethod)),
			clustermethodpars=clustermethodpars,nnruns=100,kmruns=100,
			fnruns=100,avenruns=100,multicore=TRUE,trace=F)
saveRDS(cbs,file="cbs.rds")

}else{
cbs<-readRDS(cbs,file="cbs.rds")
}
```

```{r classiftestmethod,cache=TRUE}
#then Hennig, C. (2017) Cluster validation by measurement of clustering
#characteristics relevant to the user. In C. H. Skiadas (ed.) Proceedings of
#ASMDA 2017, 501-520, https://arxiv.org/abs/1703.09282
# using clusterbenchmark from fpc
if(!file.exists("cbsiben.rds")){
set.seed(666) #the number of the beaaasttt
  options(digits=3)
clustermethod=c("kmeansCBI","hclustCBI","hclustCBI","hclustCBI","hclustCBI","hclustCBI","claraCBI")
clustermethodpars <- list()
clustermethodpars[[2]] <- clustermethodpars[[3]] <- list()
clustermethodpars[[4]] <-  clustermethodpars[[5]] <-list()
clustermethodpars[[6]]<-   clustermethodpars[[7]] <-list()
clustermethodpars[[2]]$method <- "ward.D2"
clustermethodpars[[3]]$method <- "single"
clustermethodpars[[4]]$method <- "complete"
clustermethodpars[[5]]$method <- "average"
clustermethodpars[[6]]$method <- "mcquitty"
#clustermethodpars[[7]]$method <- ""
methodname <- c("kmeans","ward","single","complete","average","mcquitty","clara")
cbs <-  clusterbenchstats(rezben$ind$coord,G=2:20,
			  clustermethod=clustermethod,scaling=FALSE,
			  methodname=methodname,
			  distmethod=rep(FALSE,length(clustermethod)),
			clustermethodpars=clustermethodpars,nnruns=100,kmruns=100,
			fnruns=100,avenruns=100,multicore=TRUE,trace=F)
saveRDS(cbs,file="cbsben.rds")
}else{
cbsben<-readRDS(cbs,file="cbsben.rds")
}
```

This comes from the quick reading of the Hennig paper found on ArXiv (fpc paper,
the metric agregation and the cluster strategy and selection to bee data - yes
bee).
To select the methods and the number of cluster, differents metrics are plotted and interpreted.
Two type of metrics: metrics to assess cluster homogeneity and metrics to assess cluster separation. The choice of the metrics has to be in line with the cluster objectives (here to reduce the dimension of the species number in DATRAS, according to some traits similarity).
Choice of the measures link to the aim of the clustering.
Some random notes taken during the reading of the Hennig's papers:


- cluster homogeneity:
  - average within-cluster dissimilarities or average distance with cluster (avewithin): individuals within cluster should be functionally more similar than individuals in different cluster (smaller values indicates better clustering quality), 
  - correlation between distances and a 0-1 vector where 0 means same cluster, 1 means different clusters (pearsongamma): group of species should represent the functional distance in the MCA space (youhouu, headache incoming), it is a representation of dissimilarity structure by clustering (a guess: higher is better?). Measure of the quality of the cluster representatiion "in some way".
- cluster seperation
  - separation index, based on the distance for every point to closest point not in the same cluster (sindex): individuals should be functionaly separated from other species (smaller values are better)
  - widest within-cluster gap (widestgap): assess connectivity (no gap in cluster : smaller value are better)

```{r classiftestmethod2,cache=TRUE}
cbsben<-cbs
#redesign cbs outputs to ease ggplot2 use
cbslong<-data.frame()
#stupid classifier
for(i in 1:4){
	tmp<-bind_rows(cbs$sim[[i]][cbs$stat$minG:cbs$stat$maxG])
	tmp$nbclus<-cbs$stat$minG:cbs$stat$maxG
	tmp$method<-names(cbs$sim)[i]
	cbslong<-rbind(cbslong,tmp)
}
#main methods
for(i in 1:7){
	tmp<-bind_rows(cbs$stat[[i]][cbs$stat$minG:cbs$stat$maxG])
	tmp$nbclus<-cbs$stat$minG:cbs$stat$maxG
	tmp$method<-cbs$stat$name[i]
	cbslong<-rbind(cbslong,tmp)
}
cbslong<-tidyr::pivot_longer(cbslong,avewithin:pamc)
#add info
cbslong<-cbslong%>%mutate(info=ifelse(name%in%c("avewithin","pearsongamma"),"Cluster homogeneity",""),
			  info=ifelse(name%in%c("sindex","widestgap"),"Cluster separation",info))
#test ggplot
stupid<-names(cbs$sim[1:4])
#all
ggplot(cbslong%>%filter(!method%in%stupid),aes(x=nbclus,y=value,color=method))+
	geom_point()+
	geom_point(data=cbslong%>%filter(method%in%stupid),aes(x=nbclus,y=value),color="grey",alpha=.2)+
	geom_point()+
	facet_wrap(~name,scale="free")
#selected metric
tmp1<-cbslong%>%filter(!method%in%stupid&info!=""&nbclus<=15)
tmp2<-cbslong%>%filter(method%in%stupid&info!=""&nbclus<=15)
ggplot(tmp1,aes(x=nbclus,y=value,color=method),alpha=..5)+
	geom_point()+
	geom_path()+
	geom_violin(data=tmp2,aes(x=nbclus,y=value,group=nbclus),color="grey",alpha=.2)+
	geom_point()+
	facet_wrap(info~name,scale="free",ncol=2)
```


Results :

- 4 clusters.

### Final temporary results and Representation for interpretation 


```{r clusterrez1,cache=TRUE}
#the final method tututttuttttttttuuuu
arbre<-cluster::agnes(rezben$ind$coord,method="ward",par.method=1)
#a plota with 4 clusters
plot(arbre,which=2,hang=-1)
rect.hclust(arbre,k=4)
#another test to check the optimal number of cluster
#funcluster<-function(a,n){list(cluster=cutree(cluster::agnes(a,method="ward"),k=n))}
#rezopti<-cluster::clusGap(rez$ind$coord,funcluster,K.max=15,B=1000)
#plot(rezopti)
#cluster::maxSE(rezopti$Tab[2:15,3],rezopti$Tab[2:15,4],method="Tibs2001SEmax")

#the cluster 
group4<-cutree(arbre,k=4) #4 clusters
group7<-cutree(arbre,k=7) #7 clusters

#how clusters are presented in 2D in the MCA subspace
fviz_mca_ind(rezben,repel=T,habillage=as.factor(group4),addEllipses=F,axes=c(1,2))
#fviz_mca_ind(rez,repel=T,habillage=as.factor(group7),addEllipses=F,axes=c(1,2))
#fviz_mca_ind(rez,repel=T,habillage=as.factor(group4),addEllipses=F,axes=c(1,3))
#fviz_mca_ind(rez,repel=T,habillage=as.factor(group4),addEllipses=F,axes=c(2,3))
```


\newpage


```{r clusterrez1fig1,cache=TRUE}
fviz_mca_ind(rez,repel=T,habillage=as.factor(group4),addEllipses=F,axes=c(1,2))
```

\newpage

# Heatmap

Nice plot but impossible to include in the markdown for now...

```{r clusterrez2,cache=TRUE,results="as.is"}
#a plot tree with dataaaa
#burtmatrix
#aa<-GDAtools::burt(pipo)
aa<-t(GDAtools::dichotom(pipo))
colnames(aa)<-rownames(pipo)
library(ComplexHeatmap)
Heatmap(aa,cluster_columns=as.dendrogram(arbre),cluster_rows=TRUE,column_order=arbre$order,
	      column_split=7,column_title="TO BE CHECKED")
#draw(hmap)


```

# Rasteriiiiiiize


```{r rasterize,cache=TRUE}
#read the data DATRAS
load("../data/J2Datras.RData")
#left_join with group7
group7nom<-data.frame(cluster=group7,spp=row.names(pipo))
J3<-left_join(J2,group7nom,by=c("ScientificName_WoRMS"="spp"))%>%filter(is.finite(cluster))
#rasterize
library(raster)
r0<- raster(nrow=5, ncol=7, xmn=-1.500034, xmx=0.7083337, ymn=49.16667, ymx=49.70833)
projection(r0)<- "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
#mhh mean of density in Nb for group 2
rall<-stack()
funmean<-function(a,na.rm=T){mean(a,na.rm=T)}
for(i in unique(J3$Year)){
	tmp<-J3%>%filter(Year==i&cluster==2)
	if(nrow(tmp)>0){
	r1<- rasterize(tmp[,c("moyLong","moyLat")], r0, fields=DensityWgt, fun=funmean)
	}else{
	r1<-r0
	}
	names(r1)<-i
	rall<-addLayer(rall,r1)
}
library(rasterVis)
levelplot(rall)

#a test for one year
plot(rall[[15]])
tmp<-J3%>%filter(Year==2002&cluster==2)
points(tmp[,c("moyLong","moyLat")])
#test interpolation ?
xy<-data.frame(xyFromCell(rall[[15]],1:ncell(rall[[15]])))
v<-getValues(rall[[15]])
#thin plate spline model
library(fields)
tps<-Tps(xy,v)
k1<-Krig(xy,v)
p<-interpolate(rall[[15]],tps)
p1<-interpolate(rall[[15]],k1)
plot(p)
p<-mask(p,rall[[15]])






```



